"""This modules defines the instrumentation of the TCP kernel stack."""
import ctypes as ct
import logging
from enum import IntEnum
from socket import AF_INET, inet_ntop

from . import HAS_MPTCP
from .template import TemplatePicker
from ..transition import FLOW_STATES
from ..utils import ThreadedComponent
from ...utils import embedded_ipv4, hash_seq_to_u64, MAX_UINT64

LOG = logging.getLogger(__name__)

BPF_SRC_NAMES = [
    'instrument_tcp.c',
    'tcp_read_utils.c'
]
if HAS_MPTCP:
    BPF_SRC_NAMES.extend((
        'instrument_mptcp.c',
        'mptcp_read_utils.c',
    ))

_TASK_COMM_LEN = 16  # from include/linux/sched.h


class TCPInstrumentation(ThreadedComponent):
    """Component processing BPF events in the TCP stack."""

    def __init__(self, Exporter=None, BPFManager=None, enable_mptcp=True,
                 naive=False):
        """Initialize the instrumentation and register the exporter."""
        super(TCPInstrumentation, self).__init__()
        self.expected_events = {
            perf_aligned_size(TransitionEvent): TransitionEvent
        }
        if HAS_MPTCP:
            self.expected_events[
                perf_aligned_size(MPTCPTransition)] = MPTCPTransition
            self.expected_events[
                perf_aligned_size(MPTCPMeta)] = MPTCPMeta
        self.ebpf = BPFManager
        LOG.debug('Activating MPTCP support' if enable_mptcp and HAS_MPTCP else
                  'Running without MPTCP support')
        if not naive:
            self.ebpf.configure(*BPF_SRC_NAMES,
                                __HAS_MPTCP="" if HAS_MPTCP and enable_mptcp
                                else None)
        else:
            src = ['tcp_naive.c'] + BPF_SRC_NAMES[1:]
            self.ebpf.configure(*src, __HAS_MPTCP=None)
        self.exporter = Exporter
        self.exporter.configure(TemplatePicker)

    def start(self):
        """Start instrumenting the TCP stack."""
        self.ebpf["transition_events"].open_perf_buffer(
            self._handle_event, page_cnt=16, lost_cb=self._handle_miss)
        super(TCPInstrumentation, self).start()

    def do_work(self):
        """Poll the BPF probes for new events."""
        self.ebpf.kprobe_poll()

    def _handle_event(self, cpu, data, size):
        try:
            struct = self.expected_events[size]
            event = ct.cast(data, ct.POINTER(struct)).contents
            self.exporter.export(event.as_event())
        except KeyError:
            LOG.warning('Unknown perf event size: %d [know: %s]',
                        size, ', '.join(
                            '%d/%s' % (k, v.__name__)
                            for k, v in self.expected_events.items()))
            return

    def _handle_miss(self, cnt):
        LOG.warning("Missed %d events! Increase the page count?", cnt)


class TransitionEvent(ct.Structure):
    """A transition event, as generated by the BPF backend."""

    _pack_ = 1
    # struct transition_event_t
    _fields_ = [
        ("transition_end", ct.c_uint64),
        ("bytes_acked", ct.c_uint64),
        ("bytes_recv", ct.c_uint64),
        ("saddr", ct.c_uint32 * 4),  # struct flow_t
        ("daddr", ct.c_uint32 * 4),
        ("sport", ct.c_uint16),
        ("dport", ct.c_uint16),
        ("family", ct.c_uint16),
        ("mss", ct.c_uint16),
        ("task", ct.c_char * _TASK_COMM_LEN),  # struct sock_stats_t
        ("pid", ct.c_uint64),
        ("duplicate_bytes", ct.c_uint64),
        ("reordering_bytes", ct.c_uint64),
        ("retransmitted_bytes", ct.c_uint64),
        ("transition_start", ct.c_uint64),
        ("duplicate_segments", ct.c_uint32),
        ("reordering", ct.c_uint32),
        ("reordering_dist", ct.c_uint32),
        ("reordering_var", ct.c_uint32),
        ("rto_events", ct.c_uint16),
        ("starting_state", ct.c_uint8),
        ("end_state", ct.c_uint8),
        ("rtt_us", ct.c_uint32),
        ("rtt_dev_us", ct.c_uint32),
        ("retransmitted_segments", ct.c_uint32),
    ]
    CONNECTION_TYPE = 'tcp'

    def as_event(self):
        """Return the FlowEvent representation of this event."""
        return {
            'flowStartReason': as_flow_state(self.starting_state),
            'flowEndReason': as_flow_state(self.end_state),
            'flowStartMicroseconds': self.transition_start,
            'flowEndMicroseconds': self.transition_end,
            'saddr': self.human_saddr(),
            'daddr': self.human_daddr(),
            'selectorId': self.connection_hash(),
            'applicationName': '%s/%d' % (self.task.decode(), self.pid),
            'sourceTransportPort': self.sport,
            'destinationTransportPort': self.dport,
            'transferredOctetTotalCount': self.bytes_acked,
            'receivedOctetTotalCount': self.bytes_recv,
            'retransmittedPacketTotalCount': self.retransmitted_segments,
            'droppedOctetTotalCount': self.retransmitted_bytes,
            'meanLatencyMilliseconds': int(self.rtt_us // 1e3),
            'rfc3550JitterMilliseconds': int(self.rtt_dev_us // 1e3),
            'duplicateOctetTotalCount': self.duplicate_bytes,
            'duplicatePacketTotalCount': self.duplicate_segments,
            'maximumIpTotalLength': self.mss,
            'stallCount': self.rto_events,
            'reorderingPacketCount': self.reordering,
            'reorderingOctetCount': self.reordering_bytes,
            'meanReorderingDistance': self.reordering_dist,
            'varReorderingDistance': self.reordering_var,
            'connection_type': self.connection_type(),
        }

    @classmethod
    def connection_type(cls):
        return cls.CONNECTION_TYPE

    def _human_addr(self, address):
        if self.family == AF_INET:
            address = embedded_ipv4(address)
        try:
            return inet_ntop(self.family, address)
        except ValueError:
            return '0.0.0.0'

    def human_saddr(self):
        """Return the human representation of the source IP address."""
        return self._human_addr(self.saddr)

    def human_daddr(self):
        """Return the human representation of the destination IP address."""
        return self._human_addr(self.daddr)

    def connection_hash(self):
        return hash_seq_to_u64(self.saddr, self.daddr,
                               self.sport.to_bytes(16, 'big'),
                               self.dport.to_bytes(16, 'big'),
                               self.task, self.pid.to_bytes(64, 'big'))


if HAS_MPTCP:
    class MPTCPTransition(TransitionEvent):
        _pack_ = 1
        _fields_ = [
            ("uuid", ct.c_uint64),
            # ("reinjected_bytes_in", ct.c_uint64),
            ("reinjected_bytes_out", ct.c_uint64),
            # ("reinjected_in", ct.c_uint32),
            ("reinjected_out", ct.c_uint32),
            ("path_id", ct.c_uint8),
        ]

        CONNECTION_TYPE = 'mptcp'

        def as_event(self):
            evt = super(MPTCPTransition, self).as_event()
            evt.update({
                # 'reinjectionPacketIn': self.reinjected_in,
                'reinjectionPacketOut': self.reinjected_out,
                # 'reinjectionOctetIn': self.reinjected_bytes_in,
                'reinjectionOctetOut': self.reinjected_bytes_out,
                'pathIndex': self.path_id,
            })
            return evt

        def connection_hash(self):
            return self.uuid % MAX_UINT64

    class MPTCPMeta(ct.Structure):
        """An MPTCP Event."""

        _pack_ = 1
        # struct transition_event_t
        _fields_ = [
            ("end_ts", ct.c_uint64),
            ("uuid", ct.c_uint64),
            ("bytes_acked", ct.c_uint64),
            ("bytes_recv", ct.c_uint64),
            ("task", ct.c_char * _TASK_COMM_LEN),
            ("pid", ct.c_uint64),
            ("reordering_bytes", ct.c_uint64),
            ("retransmitted_bytes", ct.c_uint64),
            ("start_ts", ct.c_uint64),
            ("reinjected_bytes", ct.c_uint64),
            ("reordering", ct.c_uint32),
            ("reordering_dist", ct.c_uint32),
            ("reordering_var", ct.c_uint32),
            ("reinjected", ct.c_uint32),
            ("stalls", ct.c_uint16),
            ("start_state", ct.c_uint8),
            ("end_state", ct.c_uint8),
            ("retransmitted_segments", ct.c_uint32),
            ("sk_rcvbuf", ct.c_int),
            ("subflows", ct.c_uint8),
        ]

        def as_event(self):
            return {
                'flowStartReason': as_flow_state(self.start_state),
                'flowEndReason': as_flow_state(self.end_state),
                'flowStartMicroseconds': self.start_ts,
                'flowEndMicroseconds': self.end_ts,
                'selectorId': self.uuid % MAX_UINT64,
                'stallCount': self.stalls,
                'subflowCount': self.subflows,
                'rcvBufOctetCount': self.sk_rcvbuf,
                'connection_type': 'mptcp-meta',
                'reinjectionPacketOut': self.reinjected,
                'reinjectionOctetOut': self.reinjected_bytes,
                'applicationName': '%s/%d' % (self.task.decode(), self.pid),
                'transferredOctetTotalCount': self.bytes_acked,
                'receivedOctetTotalCount': self.bytes_recv,
                'retransmittedPacketTotalCount': self.retransmitted_segments,
                'droppedOctetTotalCount': self.retransmitted_bytes,
                'reorderingPacketCount': self.reordering,
                'reorderingOctetCount': self.reordering_bytes,
                'meanReorderingDistance': self.reordering_dist,
                'varReorderingDistance': self.reordering_var,
            }


class TCP_EVENT(IntEnum):
    """The events that can be reported by the BPF kprobes."""

    TCP_EVENT_NEW = 1
    TCP_EVENT_ESTABLISHED = 2
    TCP_EVENT_FXMIT = 3
    TCP_EVENT_INCAST_DUP = 4
    TCP_EVENT_OO = 5
    TCP_EVENT_ADD_FLOW = 6
    TCP_EVENT_REM_FLOW = 7
    TCP_EVENT_RTO = 8
    TCP_EVENT_DONE = 9
    TCP_EVENT_NET_ERR = 10
    TCP_EVENT_PROTO_ERR = 11
    TCP_EVENT_DESYNC = 12


# TCP event to flow lifecycle events
TCP_STATES_TO_FLOW = {
    TCP_EVENT.TCP_EVENT_NEW: FLOW_STATES.NEW,
    TCP_EVENT.TCP_EVENT_ESTABLISHED: FLOW_STATES.ESTABLISHED,
    TCP_EVENT.TCP_EVENT_FXMIT: FLOW_STATES.ESTABLISHED,
    TCP_EVENT.TCP_EVENT_INCAST_DUP: FLOW_STATES.ESTABLISHED,
    TCP_EVENT.TCP_EVENT_OO: FLOW_STATES.ESTABLISHED,
    TCP_EVENT.TCP_EVENT_ADD_FLOW: FLOW_STATES.UPDATE,
    TCP_EVENT.TCP_EVENT_REM_FLOW: FLOW_STATES.UPDATE,
    TCP_EVENT.TCP_EVENT_RTO: FLOW_STATES.UPDATE,
    TCP_EVENT.TCP_EVENT_DONE: FLOW_STATES.FINISHED,
    TCP_EVENT.TCP_EVENT_NET_ERR: FLOW_STATES.UNREACHABLE,
    TCP_EVENT.TCP_EVENT_PROTO_ERR: FLOW_STATES.BROKEN,
    TCP_EVENT.TCP_EVENT_DESYNC: FLOW_STATES.DESYNC,
}


def as_flow_state(tcp_state):
    try:
        return TCP_STATES_TO_FLOW[TCP_EVENT(tcp_state)]
    except (KeyError, ValueError) as e:
        LOG.error(e)
        return FLOW_STATES.DESYNC


def perf_aligned_size(struct):
        # The perf record starts with a 4-byte size, then this data and is
        # aligned on 8 bytes boundaries. Adjust event sizes to reflect that.
        # add 4 to count the size, and substract from the padded length
        # we add and then 'remove' by masking just enough to jump to the next
        # multiple of 8 (or do nothing if we already had one)
        return ((4 + ct.sizeof(struct) + 7) & ~7) - 4


if __name__ == '__main__':
    print(ct.sizeof(TransitionEvent()))
    print(ct.sizeof(MPTCPMeta()))
    print(ct.sizeof(MPTCPTransition()))
